# 算法图解

- [算法图解](#算法图解)
  - [01 算法简介](#01-算法简介)
    - [算法的大O](#算法的大o)
    - [算法的速度](#算法的速度)
    - [小结](#小结)
  - [02 选择排序](#02-选择排序)
  - [03 递归](#03-递归)
  - [04 快速排序](#04-快速排序)
  - [05 散列表](#05-散列表)
  - [06 广度优先搜索](#06-广度优先搜索)
  - [07 狄克斯特拉算法](#07-狄克斯特拉算法)
  - [08 贪婪算法](#08-贪婪算法)
  - [09 动态规划](#09-动态规划)
  - [10 k最邻近算法](#10-k最邻近算法)
  - [其他](#其他)
  - [资料](#资料)

## 01 算法简介

### 算法的大O

大O(n)表示法 让你能够比较操作数，它指出了算法运行时间的增速。

下面按从快到慢的顺序列出了你经常会遇到的5种大O运行时间。

- O(log n)，也叫对数时间，这样的算法包括二分查找。
- O(n)，也叫线性时间，这样的算法包括简单查找。
- O(n * log n)，这样的算法包括第4章将介绍的快速排序——一种速度较快的排序算法。
- O(n2 )，这样的算法包括第2章将介绍的选择排序——一种速度较慢的排序算法。
- O(n!)，这样的算法包括接下来将介绍的旅行商问题的解决方案——一种非常慢的算法。

### 算法的速度

- 算法的速度指的并非时间，而是操作数的增速。
- 谈论算法的速度时，我们说的是随着输入的增加，其运行时间将以什么样的速度增加。
- 算法的运行时间用大O表示法表示。
- O(log n)比O(n)快，当需要搜索的元素越多时，前者比后者快得越多。

### 小结

- 二分查找的速度比简单查找快得多。
- O(log n)比O(n)快。需要搜索的元素越多，前者比后者就快得越多。
- 算法运行时间并不以秒为单位。
- 算法运行时间是从其增速的角度度量的。
- 算法运行时间用大O表示法表示。

## 02 选择排序

数组，链表

## 03 递归

- 基线条件 不再调用自己的条件，避免无限循环
- 递归条件 自己调用自己的条件
- 栈

## 04 快速排序

分而治之 （divide and conquer D&C）——一种著名的递归式问题解决方法。

快速排序，一种使用 `D&C` 解决问题的方法。

## 05 散列表

- 散列函数

避免冲突： 较低的填装因子； 良好的散列函数

填装因子 = 散列表包含的元素/位置总数

## 06 广度优先搜索

- 最短路径问题：

(1) 使用图来建立问题模型。 (2) 使用广度优先搜索解决问题。

图由节点（node）和边（edge）组成。

- BFS 使用queue
- DFS 使用stack

`广度优先搜索`是一种用于图的查找算法

## 07 狄克斯特拉算法

- 加权图
- 加权图的最短路径

## 08 贪婪算法

- 每一步都采取最优的做法
- 背包问题-贪婪的小偷
- 近似算法

## 09 动态规划

## 10 k最邻近算法

## 其他

## 资料

- [算法图解.pdf](https://github.com/web1992/books/blob/master/%E7%AE%97%E6%B3%95%E5%9B%BE%E8%A7%A3.pdf)
