# UDP：用户数据报协议

- User Datagram Protocol
- UDP 不提供可靠性
- UDP 长度字段指的是 UDP 首部和 UDP 数据的字节长度
- UDP 检验和覆盖 UDP 首部和 UDP 数据
- IP 首部的检验和，它只覆盖 IP 的首部
- IP 分片
- MTU
- ICMP 源站抑制差错
- RFC 768

## UDP 首部

> 图 11-2 UDP 首部

![TCP-IP-11-2.svg](./images/TCP-IP-11-2.svg)

端口号表示发送进程和接收进程。TCP 和 UDP 用目的端口号来分用来自 IP 层的数据的过程。
由于 IP 层已经把 IP 数据报分配给 TCP 或 UDP（根据 IP 首部中协议字段值），因此 TCP 端口号由 TCP 来查看，而 UDP 端口号由 UDP 来查看。
TCP 端口号与 UDP 端口号是相互独立的。

> 图 11-1 UDP 封装

![TCP-IP-11-1.svg](./images/TCP-IP-11-1.svg)

UDP 长度字段指的是 UDP 首部和 UDP 数据的字节长度。该字段的最小值为 8 字节（发送一
份 0 字节的 UDP 数据报是 OK）。这个 UDP 长度是有冗余的。IP 数据报长度指的是数据报全长
（[图 3-1](./images/TCP-IP-3-1.svg)），因此 UDP 数据报长度是全长减去 IP 首部的长度（该值在首部长度字段中指定，如[图 3-1](./images/TCP-IP-3-1.svg)所示）。

## UDP 检验和

UDP 检验和覆盖 UDP 首部和 UDP 数据。回想 IP 首部的检验和，它只覆盖 IP 的首部—并不
覆盖 IP 数据报中的任何数据。

## IP 分片

物理网络层一般要限制每次发送数据帧的最大长度。任何时候 IP 层接收到一份要发送的 IP 数据报时，它要判断向本地哪个接口发送数据（选路），
并查询该接口获得其 MTU。IP 把 MTU 与数据报长度进行比较，如果需要则进行分片。分片可以发生在原始发送端主机上，也可以发生在中间路由器上。
把一份 IP 数据报分片以后，只有到达目的地才进行重新组装（这里的重新组装与其他网络协议不同，它们要求在下一站就进行进行重新组装，而不是在最终的目的地）。
重新组装由目的端的 IP 层来完成，其目的是使分片和重新组装过程对运输层（TCP 和 UDP）是透明的，除了某些可能的越级操作外。已经分片过的数据报有可能会再次进行分片（可能不止一次）。IP 首部中包含的数据为分片和重新组装提供了足够的信息。

当 IP 数据报被分片后，每一片都成为一个分组，具有自己的 IP 首部，并在选择路由时与其他分组独立。这样，当数据报的这些片到达目的端时有可能会失序，但是在 IP 首部中有足够的信息让接收端能正确组装这些数据报片。

另外需要解释几个术语：IP 数据报是指 IP 层端到端的传输单元（在分片之前和重新组装之后），分组是指在 IP 层和链路层之间传送的数据单元。一个分组可以是一个完整的 IP 数据报，也可以是 IP 数据报的一个分片。

## 最大 UDP 数据报长度

理论上，IP 数据报的最大长度是 65535 字节，这是由 IP 首部（[图 3-1](./images/TCP-IP-3-1.svg)）16 比特总长度字段所
限制的。去除 20 字节的 IP 首部和 8 个字节的 UDP 首部，UDP 数据报中用户数据的最长长度为 65507 字节。但是，大多数实现所提供的长度比这个最大值小。

我们将遇到两个限制因素。

第一，应用程序可能会受到其程序接口的限制。socketAPI 提供了一个可供应用程序调用的函数，以设置接收和发送缓存的长度。
对于 UDPsocket，这个长度与应用程序可以读写的最大 UDP 数据报的长度直接相关。
现在的大部分系统都默认提供了可读写大于 8192 字节的 UDP 数据报（使用这个默认值是因为 8192 是 NFS 读写用户数据数的默认值）。

第二个限制来自于 TCP/IP 的内核实现。可能存在一些实现特性（或差错），使 IP 数据报长度小于 65535 字节。

> 数据报截断

由于 IP 能够发送或接收特定长度的数据报并不意味着接收应用程序可以读取该长度的数据。因此，UDP 编程接口允许应用程序指定每次返回的最大字节数。如果接收到的数据报长度大于应用程序所能处理的长度，那么会发生什么情况呢？不幸的是，该问题的答案取决于编程接口和实现。

在讨论 TCP 时，我们发现它为应用程序提供连续的字节流，而没有任何信息边界。TCP 以应用程序读操作时所要求的长度来传送数据，因此，在这个接口下，不会发生数据丢失。

## ICMP 源站抑制差错

我们同样也可以使用 UDP 产生 ICMP“源站抑制(sourcequench)”差错。当一个系统（路由器或主机）接收数据报的速度比其处理速度快时，可能产生这个差错。注意限定词“可能”。即使一个系统已经没有缓存并丢弃数据报，也不要求它一定要发送源站抑制报文。

## UDP 服务器的设计

在这里我们所感兴趣的并不是客户和服务器的编程方面（[Stevens1990]对这些方面的细节进行了讨论），而是 UDP 那些影响使用该协议的服务器的设计和实现方面的协议特性尽管我们所描述的一些特性取决于所使用UDP 的实现，但对于大多数实现来说，这些特性是公共的。

> 客户 IP 地址及端口号

来自客户的是 UDP 数据报。IP 首部包含源端和目的端 IP 地址，UDP 首部包含了源端和目的端的 UDP 端口号。当一个应用程序接收到 UDP 数据报时，操作系统必须告诉它是谁发送了这份消息，即源 IP 地址和端口号。这个特性允许一个交互 UDP 服务器对多个客户进行处理。给每个发送请求的客户发回应答。

> UDP 输入队列

大多数 UDP 服务器是交互服务器。这意味着，单个服务器进程对单个 UDP 端口上（服务器上的名知端口）的所有客户请求进行处理。
通常程序所使用的每个 UDP 端口都与一个有限大小的输入队列相联系。这意味着，来自不同客户的差不多同时到达的请求将由 UDP 自动排队。接收到的 UDP 数据报以其接收顺序交给应用程序（在应用程序要求交送下一个数据报时）。

然而，排队溢出造成内核中的 UDP 模块丢弃数据报的可能性是存在的。

- 限制本地 IP 地址
- 目的 IP 地址
- 限制远端 IP 地址

## Links

- [https://datatracker.ietf.org/doc/html/rfc768](https://datatracker.ietf.org/doc/html/rfc768)
