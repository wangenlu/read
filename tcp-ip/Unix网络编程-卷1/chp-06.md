# I/O 复用 select 和 poll 函数

在 5.12 节中,我们看到 TCP 客户同时处理两个输入:标准输入和 TCP 套接字。我们遇到的问
题是就在客户阻塞于(标准输入上的) fgets 调用期间,服务器进程会被杀死。服务器 TCP 虽然
正确地给客户 TCP 发送了一个 FIN,但是既然客户进程正阻塞于从标准输入读入的过程,它将看
不到这个 EOF,直到从套接字读时为止(可能已过了很长时间)。

这样的进程需要一种预先告知内核的能力,使得内核一旦发现进程指定的一个或多个 ⅣO 条件就绪(也就是说输入已准备好被
读取,或者描述符已能承接更多的输出),它就通知进程。这个能力称为 IO 复用(IOmultiplexing),
是由 select 和 po11 这两个函数支持的。我们还介绍前者较新的称为 select 的 POSIX 变种。

5 种 I/O 模型:

在介绍 selec 和 po1 这两个函数之前,我们需要回顾整体,查看 Unⅸ 下可用的 5 种 I/O 模型的基本区别:

- 阻塞式 IO;
- 非阻塞式 IO;
- IO 复用(selec 和 poll)
- 信号驱动式 IO( SIGIO);
- 异步 IO(POSX 的 aio\_系列函数)。

正如我们将在本节给出的所有例子所示,一个输入操作通常包括两个不同的阶段
(1)等待数据准备好;
(2)从内核向进程复制数据。
对于一个套接字上的输入操作,第一步通常涉及等待数据从网络中到达。当所等待分组到达
时,它被复制到内核中的某个缓冲区。第二步就是把数据从内核缓冲区复制到应用进程缓冲区。
