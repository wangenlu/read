# 第22章 后悔了怎么办-undo日志（上）

- 事务回滚的需求
- undo log
- 事务id    
- START TRANSACTION READ ONLY 语句开启一个只读事务
- START TRANSACTION READ WRITE 语句开启一个读写事务
- trx_id隐藏列
- roll_pointer的隐藏列
- 为row_id的隐藏列
- undo日志的格式
- FIL_PAGE_UNDO_LOG
- 系统表空间中分配 / undo tablespace 中分配
- TRX_UNDO_INSERT_REC 的 undo日志
- roll_pointer 本质就是一个指针，指向记录对应的undo日志
- PAGE_FREE 属性的值代表指向 垃圾链表
- 删除数据
- 重新组织页面 页面碎片
- TRX_UNDO_DEL_MARK_REC 日志
- undo log  版本链
- insert undo 日志
- delete undo 日志
- update undo 日志
- TRX_UNDO_UPD_EXIST_REC 的 undo日志
- TRX_UNDO_DEL_MARK_REC  的 undo日志

## 事务回滚的需求

- 情况一：事务执行过程中可能遇到各种错误，比如服务器本身的错误，操作系统错误，甚至是突然断电导致的错误。
- 情况二：程序员可以在事务执行过程中手动输入 ROLLBACK 语句结束当前的事务的执行

## 事务id

有的时候虽然我们开启了一个读写事务，但是在这个事务中全是查询语句，并没有执行增、删、改的语句，那也就意味着这个事务并不会被分配一个 事务id 。

## 删除数据

- 阶段一：仅仅将记录的 delete_mask 标识位设置为 1 ，其他的不做修改（其实会修改记录的 trx_id 、roll_pointer 这些隐藏列的值）。设计 InnoDB 的大叔把这个阶段称之为 delete mark 。

- 阶段二：当该删除语句所在的事务提交之后，会有专门的线程后来真正的把记录删除掉。所谓真正的删除就是把该记录从 正常记录链表 中移除，并且加入到 垃圾链表 中，然后还要调整一些页面的其他信息，比如页面中的用户记录数量 PAGE_N_RECS 、上次插入记录的位置 PAGE_LAST_INSERT 、垃圾链表头节点的指针PAGE_FREE 、页面中可重用的字节数量 PAGE_GARBAGE 、还有页目录的一些信息等等。设计 InnoDB 的大叔把这个阶段称之为 purge 。

对照着图我们还要注意一点，将被删除记录加入到 垃圾链表 时，实际上加入到链表的头节点处，会跟着修改 PAGE_FREE 属性的值。

## 更新 undo log

- 不更新主键的情况

-  就地更新（in-place update

更新记录时，对于被更新的每个列来说，如果更新后的列和更新前的列占用的存储空间都一样大，那么就可
以进行 就地更新 ，也就是直接在原记录的基础上修改对应列的值。再次强调一边，是每个列在更新前后占
用的存储空间一样大，有任何一个被更新的列更新前比更新后占用的存储空间大，或者更新前比更新后占用
的存储空间小都不能进行 就地更新 。

- 先删除掉旧记录，再插入新记录

在不更新主键的情况下，如果有任何一个被更新的列更新前和更新后占用的存储空间大小不一致，那么就需
要先把这条旧的记录从聚簇索引页面中删除掉，然后再根据更新后列的值创建一条新的记录插入到页面中。
请注意一下，我们这里所说的 删除 并不是 delete mark 操作，而是真正的删除掉，也就是把这条记录从 正
常记录链表 中移除并加入到 垃圾链表 中，并且修改页面中相应的统计信息（比如 PAGE_FREE 、
PAGE_GARBAGE 等这些信息）。不过这里做真正删除操作的线程并不是在唠叨 DELETE 语句中做 purge 操作
时使用的另外专门的线程，而是由用户线程同步执行真正的删除操作，真正删除之后紧接着就要根据各个列
更新后的值创建的新记录插入。
这里如果新创建的记录占用的存储空间大小不超过旧记录占用的空间，那么可以直接重用被加入到 垃圾链
表 中的旧记录所占用的存储空间，否则的话需要在页面中新申请一段空间以供新记录使用，如果本页面内已
经没有可用的空间的话，那就需要进行页面分裂操作，然后再插入新记录。