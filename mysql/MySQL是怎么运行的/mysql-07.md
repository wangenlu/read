# 第7章 好东西也得先学会怎么用-B+树索引的使用

- B+树索引的特点
- 索引的代价
- 空间上的代价
- 时间上的代价
- 索引失效
- 精确匹配
- 匹配列前缀
- 匹配范围值
- 精确匹配某一列并范围匹配另外一列
- 用于排序 (filesort)
- 用于分组
- 顺序I/O 
- 随机I/O
- 全表扫描
- 二级索引 + 回表 
- 查询优化器
- 覆盖索引 -> 最好在查询列表里只包含索引列(省去了`回表`操作带来的性能损耗)
- 索引列前缀
- 让索引列在比较表达式中单独出现
- 页面分裂


## B+树索引的特点

每个索引都对应一棵 B+ 树， B+ 树分为好多层，最下边一层是叶子节点，其余的是内节点。所有`用户记录`都存储在 B+ 树的叶子节点，所有`目录项记录` 都存储在内节点(非叶子节点)。

InnoDB 存储引擎会自动为主键（如果没有它会自动帮我们添加）建立`聚簇索引` ，聚簇索引的叶子节点包含完整的用户记录。

我们可以为自己感兴趣的列建立 二级索引 ， 二级索引 的叶子节点包含的用户记录由 索引列 + 主键 组成，所以如果想通过 二级索引 来查找完整的用户记录的话，需要通过 回表 操作，也就是在通过 二级索引找到主键值之后再到 聚簇索引 中查找完整的用户记录。

B+ 树中每层节点都是按照索引列值从小到大的顺序排序而组成了双向链表，而且每个页内的记录（不论是用户记录还是目录项记录）都是按照索引列的值从小到大的顺序而形成了一个单链表。如果是 联合索引 的话，则页面和记录先按照 联合索引 前边的列排序，如果该列值相同，再按照 联合索引后边的列排序。

通过索引查找记录是从 B+ 树的根节点开始，一层一层向下搜索。由于每个页面都按照索引列的值建立了Page Directory （页目录），所以在这些页面中的查找非常快。

## 索引的代价

> 空间上的代价
这个是显而易见的，每建立一个索引都要为它建立一棵 B+ 树，每一棵 B+ 树的每一个节点都是一个数据页，一个页默认会占用 16KB 的存储空间，一棵很大的 B+ 树由许多数据页组成，那可是很大的一片存储空间呢。

> 时间上的代价

每次对表中的数据进行增、删、改操作时，都需要去修改各个 B+ 树索引。而且我们讲过， B+ 树每层节点都
是按照索引列的值从小到大的顺序排序而组成了双向链表。不论是叶子节点中的记录，还是内节点中的记录
（也就是不论是用户记录还是目录项记录）都是按照索引列的值从小到大的顺序而形成了一个单向链表。而
增、删、改操作可能会对节点和记录的排序造成破坏，所以存储引擎需要额外的时间进行一些记录移位，页
面分裂、页面回收啥的操作来维护好节点和记录的排序。如果我们建了许多索引，每个索引对应的 B+ 树都
要进行相关的维护操作，这还能不给性能拖后腿么？


## 不可以使用索引进行排序的几种情况

- ASC、DESC混用
- WHERE子句中出现非排序使用到的索引列
- 排序列包含非同一个索引的列
- 排序列使用了复杂的表达式

## 如何挑选索引

