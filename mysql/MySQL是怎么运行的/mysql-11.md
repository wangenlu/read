# 第11章 两个表的亲密接触-连接的原理

- join
- 笛卡尔积
- 依次匹配的组合
- 驱动表 被驱动表
- 就是说从const、ref、ref_or_null、range、index、all这些执行方法中选取代价最小的去执行查询
- 内连接和外连接
- 驱动表中的记录即使在被驱动表中没有匹配的记录，也仍然需要加入到结果集
- 左外连接 选取左侧的表为驱动表
- 右外连接 选取右侧的表为驱动表
- 对于 内连接 的两个表，驱动表中的记录在被驱动表中找不到匹配的记录，该记录不会加入到最后的结果集，我们上边提到的连接都是所谓的 内连接
- 对于 外连接 的两个表，驱动表中的记录即使在被驱动表中没有匹配的记录，也仍然需要加入到结果集
- on 连接条件
-  LEFT [OUTER] JOIN
- 对于左（外）连接和右（外）连接来说，必须使用 ON 子句来指出连接条件
- eq_ref
- 基于块的嵌套循环连接（Block Nested-Loop Join）
- 尽量减少访问被驱动表的次数
- join buffer 执行连接查询前申请的一块固定大小的内存
- join buffer 存储的是驱动表的数据
- join buffer 减少I/O
- join buffer + Block Nested-Loop Join  

## eq_ref

我们知道在单表中使用主键值或者唯一二级索引列的值进行等值查找的方式称之为 const ，而设计 MySQL 的大叔把在连接查询中对被驱动表使用主键
值或者唯一二级索引列的值进行等值查找的查询执行方式称之为： eq_ref

另外，有时候连接查询的查询列表和过滤条件中可能只涉及被驱动表的部分列，而这些列都是某个索引的一部
分，这种情况下即使不能使用 eq_ref 、 ref 、 ref_or_null 或者 range 这些访问方法执行对被驱动表的查询的
话，也可以使用索引扫描，也就是 index 的访问方法来查询被驱动表。所以我们建议在真实工作中最好不要使
用 * 作为查询列表，最好把真实用到的列作为查询列表。

## Join

连接的本质就是把各个连接表中的记录都取出来依次匹配的组合加入结果集并返回给用户。不论
哪个表作为驱动表，两表连接产生的笛卡尔积肯定是一样的。而对于内连接来说，由于凡是不符合 ON 子句或
WHERE 子句中的条件的记录都会被过滤掉，其实也就相当于从两表连接的笛卡尔积中把不符合过滤条件的记录给
踢出去，所以对于内连接来说，驱动表和被驱动表是可以互换的，并不会影响最后的查询结果。但是对于外连接
来说，由于驱动表中的记录即使在被驱动表中找不到符合 ON 子句连接条件的记录，所以此时驱动表和被驱动表
的关系就很重要了，也就是说左外连接和右外连接的驱动表和被驱动表不能轻易互换。

## join buffer

另外需要注意的是，驱动表的记录并不是所有列都会被放到 join buffer 中，只有查询列表中的列和过滤条件中
的列才会被放到 join buffer 中，所以再次提醒我们，最好不要把 * 作为查询列表，只需要把我们关心的列放到
查询列表就好了，这样还可以在 join buffer 中放置更多的记录呢哈。