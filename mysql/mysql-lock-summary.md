# MySQL 锁的概述

## 提出问题

> 为什么需要锁？

数据库系统使用锁是为了支持对共享资源进行并发访问,提供数据的`完整性`和`一致性`。

## 锁的分类

InnoDB存储引擎实现了如下两种标准的行级锁:

- 共享锁(S Lock)，允许事务读一行数据。
- 排他锁(X Lock)，允许事务删除或更新一行数据。

> 意向锁

此外，InnoDB 存储引擎支持多粒度(granular)锁定，这种锁定允许事务在行级上的
锁和表级上的锁同时存在。为了支持在不同粒度上进行加锁操作，InnoDB 存储引擎支持
一种额外的锁方式，称之为意向锁(Intention Lock)。意向锁是将锁定的对象分为多个层
次，意向锁意味着事务希望在更细粒度(fine granularity)上进行加锁，如图6-3所示。

> 意向共享锁 意向排他锁

- 1)意向共享锁(IS Lock),事务想要获得一张表中某几行的共享锁
- 2)意向排他锁(IX Lock)，事务想要获得一张表中某几行的排他锁

## 锁对象

表、页、行

![MySQL-6-3.drawio.svg](./images/MySQL-6-3.drawio.svg)

## 锁的实现 (3种算法)

- Record Lock: 单个行记录上的锁
- Gap Lock: 间隙锁，锁定一个范围，但不包含记录本身
- Next-Key Lock : Gap Lock + Record Lock, 锁定一个范围，并且锁定记录本身

Next-Key Lock降级为Record Lock仅在查询的列是唯一索引的情况下。

## 锁SQL

- SELECT ... FOR UPDATE (X锁)
- SELECT ... LOCK IN SHARE MODE (S锁)

## 锁问题

- 幻读 (Phantom Problem) 是指在同一事务下，连续执行两次同样的SQL语句可能导致不同的结果，第二次的SQL语句可能会返回之前不存在的行。
- 脏度 (Dirty Read) 即一个事务可以读到另外一个事务中未提交的数据，则显然违反了数据库的隔离性。
- 不可重复度
- 阻塞
- 死锁

> 不可重复读

不可重复读是指在一个事务内多次读取同一数据集合。在这个事务还没有结束时，另外一个事务也访问该同一数据集合，并做了一些DML操作。因此，在第一个事务中的两次读数据之间，
由于第二个事务的修改，那么第一个事务两次读到的数据可能是不一样的。这样就发生了在一个事务内两次读到的数据是不一样的情况，这种情况称为不可重复读。

不可重复读和脏读的区别是:脏读是读到未提交的数据，而不可重复读读到的却是已经提交的数据，但是其违反了数据库事务一致性的要求。

一般来说，不可重复读的问题是可以接受的，因为其读到的是已经提交的数据，本身并不会带来很大的问题。
很多数据库将其数据库事务的默认隔离级别设置为READ COMMITTED,在这种隔离级别下允许不可重复读的现象。

在InnoDB存储引擎中，通过使用Next-Key Lock算法来避免不可重复读的问题。在MySQL官方文档中将不可重复读的问题定义为Phantom Problem，即幻像问题。
在Next-Key Lock算法下，对于索引的扫描，不仅是锁住扫描到的索引，而且还锁住这些索引覆盖的范围(gap)。
因此在这个范围内的插人都是不允许的。这样就避免了另外的事务在这个范围内插人数据导致的不可重复读的问题。
因此，InnoDB 存储引擎的默认事务隔离级别是READ REPEATABLE,采用Next-Key Lock算法，避免了不可重复读的现象。

> 阻塞

在InnoDB存储引擎中，参数innodb_lock_wait_timeout 用来控制等待的时间(默认是50秒)，`innodb_rollback_on_timeout`用来设定是否在等待超时时对进行中的事务进行
回滚操作( 默认是OFF，代表不回滚)。参数innodb_lock_wait_timeout 是动态的，可以再运行时调整。

需要牢记的是，在默认情况下InnoDB存储引擎不会回滚超时引发的错误异常。其实InnoDB存储引擎在大部分情况下都不会对异常进行回滚。


> 死锁

死锁是指两个或两个以上的事务在执行过程中，因争夺锁资源而造成的一种互相等待的现象。若无外力作用，事务都将无法推进下去。

