# 第一章 绪论

- 多用户系统
- 用户和组
- 进程
- ln 硬连接
- 软连接 soft link
- 符号连接 symbolic link  (ln -s )
- 进程模式
- 内核模式
- system call
- 进行描述符 process descriptor
- 信号量

## 操作系统

操作系统的基本概念，操作系统必须完成两个主要目标:

- 与硬件部分交互，为包含在硬件平台上的所有低层可编程部件提供服务。
- 为运行在计算机系统上的应用程序(即所谓用户程序)提供执行环境。

一些操作系统允许所有的用户程序都直接与硬件部分进行交互(典型的例子是MS-DOS)。与此相反，类Unix操作系统把与计算机物理组织相关的所有低层细节都对用户
运行的程序隐藏起来。当程序想使用硬件资源时，必须向操作系统发出一个请求。内核对这个请求进行评估，如果允许使用这个资源，那么;内核代表应用程序与相关的硬件部分进行交互。

为了实施这种机制，现代操作系统依靠特殊的硬件特性来禁止用户程序直接与低层硬件部分进行交互，或者禁止直接访问任意的物理地址。特别是,硬件为CPU引入了至少两
种不同的执行模式:用户程序的非特权模式和内核的特权模式。Unix把它们分别称为用户态(User Mode)和内核态(Kernel Mode)。

所有的操作系统都使用一种基本的抽象:进程(process).一个进程可以定义为:“程序执行时的一个实例”，或者一个运行程序的“执行上下文”。在传统的操作系统中，一个
进程在地址空间(addressspace)中执行一个单独的指令序列。地址空间是允许进程引用的内存地址集合。现代操作系统允许具有多个执行流的进程，也就是说，在相同的地
址空间可执行多个指令序列。

## 文件操作

```c
    fd = open(path, flag, mode);
    newoffse t= lseek(fd, offset, whence);
    nread = read(fd, buf, count);
```

## 进程的实现

为了让内核管理进程，每个进程由一个进程描述符(process descriptor)表示，这个描述符包含有关进程当前状态的信息。
当内核暂停一个进程的执行时,就把几个相关处理器寄存器的内容保存在进程描述符中。这些寄存器包括:

- 程序计数器(PC) 和栈指针(SP) 寄存器
- 通用寄存器
- 浮点寄存器
- 包含CPU状态信息的处理器控制寄存器(处理器状态字，Processor Status Word )
- 用来跟踪进程对RAM访问的内存管理寄存器

当内核决定恢复执行一个进程时，它用进程描述符中合适的字段来装载CPU寄存器。因为程序计数器中所存的值指向下一条将要执行的指令,所以进程从它停止的地方恢复执行。

## 信号量

广泛使用的一种机制是信号量(semaphore),它在单处理器系统和多处理器系统上都有效。信号量仅仅是与一个数据结构相关的计数器。所有内核线程在试图访问这个数据结构之前，都要检查这个信号量。可以把每个信号量看成一个对象，其组成如下:

- 一个整数变量
- 一个等待进程的链表;
- 两个原子方法: down( )和up()

down()方法对信号量的值减1,如果这个新值小于0,该方法就把正在运行的进程加人到这个信号量链表，然后阻塞该进程( 即调用调度程序)。up()方法对信号量的值加1，
如果这个新值大于或等于0，则激活这个信号量链表中的一个或多个进程。每个要保护的数据结构都有它自己的信号量，其初始值为1。当内核控制路径希望访问
这个数据结构时，它在相应的信号量上执行down()方法。如果信号量的当前值不是负数，则允许访问这个数据结构。否则，把执行内核控制路径的进程加入到这个信号量的
链表并阻塞该进程。当另一个进程在那个信号量上执行up()方法时,允许信号量链表上的一个进程继续执行。