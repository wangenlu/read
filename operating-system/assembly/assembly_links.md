# assembly

## 关键字

- 段式管理
- 页式管理
- 局描述符表（Global Descriptor Table, GDT)
- 总的来说，现代的操作系统都是采用段式管理来做基本的权限管理，而对于内存的分配、回收、调度都是依赖页式管理
- 中断描述符表（Interruption Description Table, IDT)
- 中断根据中断来源的不同，又可以细分为 Fault、Trap、Abort 以及普通中断

## 指令说明

指令|作用|
|---|---|
mov  | 将源操作数复制到目的操作数。可以实现赋值语句。
xchg | 交换两个操作数的内容，例如xchg %ax, %bx
inc/dec | 寄存器或内存操作数加1/减1 
add | 将长度相同的两个操作数进行相加操作，结果存入目的操作数。例如add %ax,%bx，即bx += ax。注意intel语法和AT&T语法的不同。
sub | 从目的操作数中减去源操作数
and | 按位与。常用技巧: char* p; (p & -8)进行8字节对齐。
or  | 按位或
xor | 按位异或
not | 按位取反
shl/shr | 操作数按位向左/右移动。根据不同的补充空位的方法，可以分为算术/逻辑/循环等不同的类型。左移相当于乘2，右移相当于除以2。当乘数或者除数刚好是2的整数次幂时，可以使用移位操作代替
test | 在两个操作数的对应位之间进行And操作，并根据运算结果设置符号标志位，零标志位和奇偶标志位。
cmp  | 比较整数。执行从目的操作数中减去源操作数的隐含减法操作，并且不修改任何操作数。
jmp  | 跳转指令，控制流转向目标地址执行。可以影响RIP。
j(cond) |条件跳转。只有标记位满足某个条件时才会发生跳转。例如，JZ表示为零跳转，JG表示大于跳转，JLE表示小于等于跳转等等。条件有很多，这里就不再一一举例了。有需要的同学请自行查阅。
call | 用于函数调用。对控制流的影响和jmp指令是一样的。它与jmp最大的不同是，call指令会把它的下一条指令压入栈上，等待从被调用者返回时再恢复到下一条指令执行。call指令传递参数的方法根据不同的操作系统会有所不同，例如linux规定在64位x86寄存器上，前6个整型参数要通过rdi, rsi, rdx, rcx, r8, r9来传递。一个操作系统关于入参方式的规定就是应用程序二进制接口（Application BinaryInterface， ABI）。
ret  | 从被调用者返回。跳转的目标地址是从栈上取得的，这也是call指令压入的那个地址。也就是call指令的下一条地址。整型或者指针类型的返回值在rax中。
movsb(w, d) | 传送字符串数据。将ESI寻址的内存数据复制到EDI寻址的内存位置
cmpsb | 比较字符串。比较ESl和EDI寻址的内存数据
scasb | 扫描字符串:比较累加器EAX与EDI寻址的内存数据
stosb | 保存字符串:将累加器EAX的内容保存到EDI寻址的位置
lodsb | 从字符串加载到累加器:将ESI寻址的内存数据加载到累加器
rep   | ECX>0时重复。举例:传送10个字符串。mov $10, %ecx; rep movsb

## Links

- [CPU 总线](https://www.cnblogs.com/yilang/p/11005532.html)
- [8086CPU简介](https://www.cnblogs.com/BoyXiao/archive/2010/11/20/1882716.html)
- [x86汇编基础-Move指令和基本寻址](https://www.jianshu.com/p/fd1cfed8a2d2)