# 第二章 信息的表示和处理

- bit 位
- 无符号 unsigned
- 补码 tow's complement
- 有符号
- 浮点数 floating-point
- 溢出 overflow
- 虚拟内存 巨大的数组 virtual memory
- 十六进制 二进制转化 A C F
- A 1010
- C 1100
- F 1111
- 字长 word size
- 虚拟地址是一个字来编码
- 32位和64位的典型值
- int32_t(4字节) int64_t(8字节) 避免不同编译器之间不同的差异 （ISO 99）
- unsigned long
- unsigned long int
- long unsigned
- long unsigned
- 寻址和字节顺序
- 对象的地址是什么，以及在内存中是如何排列这些字节的
- 前一种规则 最低有效字节在最前面的方式，称为小端法(little endian)
- 后一种规则 最高有效字节在最前面的方式，称为大端法(big endian)
- 网络传输顺序
- 阅读顺序，编译器的顺序
- C语言，指针和数组
- man ascii
- 二进制编码是不兼容的 (大小端)
- 布尔代数 Boolean algebra
- 位向量 表示有限的集合
- 加法逆元 additive inverse (P72)
- C语言 位移操作 (P76)
- 左移
- 逻辑右移 算术右移 (P76)
- 整数的表示
- 补码编码 two' s-complement
- 双摄

## sizeof

这些过程使用C语言的运算符sizeof来确定对象使用的字节数。一般来说，表达式sizeof(T)返回存储一个类型为T的对象所需要的字节数。使用sizeof而不是一个固定的值，是向编写在不同机器类型上可移植的代码迈进了一步。

## 位移操作

- 逻辑右移：有符合，无符号，的结果都是一样的
- 算术右移：如果是有符合的（负数），那么结果会在最高位填充符号位 


![CSAPP-算数右移.drawio.svg](./images/CSAPP-算数右移.drawio.svg)

斜体的数字表示的是最右端(左移)或最左端(右移)填充的值。可以看到除了一个条目之外，其他的都包含填充0。唯一的例外是算术右移`[10010101]`的情况。因为操作数的最高位是1，填充的值就是1。

C语言标准并没有明确定义对于有符号数应该使用哪种类型的右移一算术右移或者逻辑右移都可以。不幸地，这就意味着任何假设一种或者另一种右移形式的代码都可能会遇到可移植性问题。然而，实际上，几乎所有的编译器/机器组合都对有符号数使用算术右移，且许多程序员也都假设机器会使用这种右移。另一方面，对于无符号数，右移必须是逻辑的。

与C相比，Java对于如何进行右移有明确的定义。表达是`x>>k`会将x算术右移k个位置，而`x>>>k`会对x做逻辑右移。

## 补码

2.2.3补码编码
对于许多应用，我们还希望表示负数值。最常见的有符号数的计算机表示方式就是补码(two' s-complement)形式。
在这个定义中，将字的最高有效位解释为负权(negative weight)。我们用函数B2Tw (Binary to Two' s-complement的缩写，长度为w)来表示。