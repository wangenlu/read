# 第二章 标记-清扫回收

- 三色抽象
- 标记-清扫算法
- 位图标记
- 空间大小分级 size class

标记-清扫( mark-sweep)、标记-复制(mark-copy)、 标记-整理( mark-compact)、引
用计数(reference counting)是 4 种最基本的垃圾回收策略。大多数回收器可能会以不同的
方式对这些基本回收策略进行组合，例如在堆中某一区域使用一种回收策略，而在另一个区域使用另一种回收策略。

在对这 4 种基本回收策略进行描述时，我们假设赋值器运行在一个或者多个线程之上，
且**只有一个回收器线程**，当回收器线程运行时，所有的**赋值器线程**均处于停止状态。这种
“万物静止”(stop the world)的策略大幅简化了回收器的实现。

从赋值器线程角度来看，回收过程的执行是原子性的，即赋值器线程感知不到回收器的任何中间状态，
回收器也不会受到赋值器线程的任何干扰。我们假设当回收过程开始时，赋值器线程停止在一个允许回收器
安全扫描其根集合的回收点，具体的运行时接口我们将在第 11 章详述。

通过“万物静止”的方法可以获取**堆的快照**，因此回收器在进行对象存活性判定时不用担心赋值器将堆中对象
的拓扑结构重新排列。这同时也意味着在回收器释放内存的过程中，我们无需担心在同一时
刻存在其他回收器释放内存或者赋值器线程申请内存，进而避免在线程之间引人额外的同步
机制。多赋值器线程同时获取内存的情况我们将在第 7 章讨论，多回收器线程，或者赋值器
与回收器并发执行的情况将导致运行时系统更加复杂，我们将在后面的章节中进行讨论。

理想的垃圾回收的目的是回收程序不再使用的对象所占用的空间，任何自动内存管理系
统都面临 3 个任务:

- 1)为新对象分配空间。
- 2)确定存活对象。
- 3)回收死亡对象所占用的空间。

这些任务并非相互独立，特别是回收空间的方法影响着分配新空间的方法。正如第 1 章
所提到的，真正的存活性问题是一个不可确定的问题，因此我们使用指针可达性(参见 1.6
节)来近似对象的存活性:只有当堆中存在一条从根出发的指针链能最终到达某个对象时，
才能认定该对象存活，更进一步，如果不存在这样一条指针链，则认为对象死亡，其空间可
以得到回收。尽管存活对象集合中可能包含一些永远不会再被赋值器访问的对象，但是死亡
对象集合中的对象却必定是死亡的。

标记-清扫算法[McCarthy,1960]是我们将要介绍的第一种回收算法，它是在指针
可达性递归定义指导下最直接的回收方案。

它的回收过程分为两个阶段:

第一阶段为追踪(trace)阶段，即回收器从根集合(寄存器、线程栈、全局变量)开始遍历对象图，并标记(mark)所遇到的每个对象;
第二阶段为清扫(sweep) 阶段，即回收器检查堆中每一个对象，并将所有`未标记`的对象当作垃圾进行回收。

标记-清扫算法是一种间接回收( indirect collection)算法，它并非直接检测垃圾本身，
而是先确定所有存活对象，然后反过来判定其他对象都是垃圾。需要注意的是，该算法的每
次调用都需要重新计算存活对象集合，但并非所有的垃圾回收算法都需要如此。第 5 章将介
绍一种直接回收( direct collection) 策略，即引用计数。与间接回收不同，直接回收可以通
过对象本身来判断其存活性，因此其不需要额外的追踪过程。

## 标记-清扫算法

从垃圾回收器角度来看，赋值器线程所执行的只有 3 种操作:`创建`、`读`、`写`。每一个回
收算法必须对这 3 种操作进行合理的重定义(1.6 节给出了默认的定义)。标记-清扫算法
与赋值器之间的接口十分简单:如果线程无法分配对象，则唤起回收器，然后再次尝试分配
(如算法 2.1 所示)。为了强调回收器工作在“万物静止”模式下而非与赋值器线程并发执行，
我们特别使用 `atomic` 关键字来标记回收程序。如果回收完成之后仍然没有足够的内存以满
足分配需求，则说明堆内存耗尽。

```c
// 算法 2.1 标记-清扫：分配
New():
    ref <- allocate()
    if ref = null /*堆中无可用空间*/
        collect()
        ref <- allocate()
    if ref= null
        /*堆中仍然无可用空间*/
        error "Out of memory"
    return ref

atomic collect():
    markF romRoots( )
    sweep(HeapStart, HeapEnd)
```

```c
// 算法 2.2 标记-清扫: 标记
markFromRoots():
    initialise(worklist)
    for each fld in Roots
        ref <- *fld
        if ref != null & not isMarked(ref)
            setMarked(ref)
            add(worklist, ref)
            mark()

initialise(worklist):
    worklist < - empty

mark():
    while not isEmpty(worklist)
        ref <- remove(worklist)  /* ref已经标记过*/
        for each fld in Pointers(ref)
        child t <- *fld
        if child != null && not isMarked(child)
            setMarked(child)
            add(worklist, child)
```

```c
// 算法 2.3 标记-清扫:清扫
sweep(start, end):
scan <- start
while scan < end
    if isMarked( scan)
        unsetMarked(scan)
    else free(scan)
        scan <- nextObject(scan)
```

我们将在第 7 章之后讨论 allocate 和 free 的具体实现细节，但需要注意的是，标记-清
扫回收器要求堆布局满足一定的条件:第一，标记-清扫回收器不会移动对象，因此内存管理
器必须能够控制堆内存碎片，这是因为过多的内存碎片可能会导致分配器无法满足新分配请
求，从而增加垃圾回收频率，在更坏情况下，新对象的分配可能根本无法完成;第二，清扫
器必须能够遍历堆中每一个对象，即对于给定对象，不管其后是否存在一些用于对齐的填充
字节，sweep 方法都必须能够找到下一一个对象，因此用 nextobject 方法要完成堆的遍历，仅获
取对象的大小信息是远远不够的(算法 2.3 中的第 7 行)。我们将在第 7 章讨论堆的可遍历性。

## size class

算法 2.5 演示了使用懒惰清扫策略处理整个内存块的方法。分配器通常只会在一个内存
块中分配相同大小的对象(在第 7 章中详述),每种`空间大小分级`( size class)都会对应一个
或多个用于分配的内存块，以及一个待回收内存块链表( reclaim list of blocks)。在回收过程
