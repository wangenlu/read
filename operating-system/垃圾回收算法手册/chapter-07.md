# 第七章 内存分配

关键字：

- 顺序分配 (sequential allocation)
- 空闲链表分配 (free-list allocation)
- 多空闲链表分配 (multiple free-list)

内存管理器需要处理的问题包括 3 个方面:

- ① 如何分配内存;
- ② 如何确定存活数据;
- ③ 如何回收死亡对象所占用的空间;

以便在程序的后续执行过程中重新将其分配出去。对于这了个问题，`垃圾回收系统`和`显式内存管理器`有着不同的处理策略，
且不同回收器所使用的算法也各不相同。但不论如何，内存的分配和回收过程都是紧密相关的，
使用任何一种分配策略都必须要考虑如何回收其所分配的内存。

本章将首先介绍两种基本的分配策略:`顺序分配`(`sequential allocation`)与`空闲链表`分配
(`free-list allocation`)， 紧接着是基于`多空闲链表`(`multiple free-list`) 的更加复杂的分配。
然后将介绍其他--些实用的注意事项。本章最后将对选择分配策略时需要考虑的因素进行总结。

## 顺序分配

顺序分配使用一个较大的空闲内存块。对于 n 字节的内存分配请求，顺序分配将从空闲
块的一端开始进行分配，其所需的数据结构十分简单，只需要一个空闲指针(`free pointer`)
和一个界限指针(`limit pointer`)。算法 7.1 展示了顺序分配的伪代码，其内存分配方向是从
低地址到高地址，图 7.1 对其分配过程进行了描述。由于顺序分配策略总是简单地移动空闲
指针，所以俗称为阶跃指针分配(`bump pointer allocation`)。在某些场景下，顺序分配也被
称为线性分配(`linear allocation`)，因为对于指定内存块而言，其所分配地址的顺序总是线性
的。关于分配过程中的字节对齐以及填充(`padding`)要求，参见 7.6 节和 7.8 节。顺序分配
的特征如下:

- 简单。
- 高效(尽管 Blackburn 等[2004]指出，对于 Java 系统而言，顺序分配和分区适应空闲链表分配(见 7.4 节)之间的性能差距不超过 1%的整体执行时间)。
- 相对于空闲链表分配，顺序分配可以给赋值器带来更好的高速缓存局部性，特别是对于移动式回收器中对象的初次分配。
- 与空闲链表分配相比，顺序分配不适用于非移动式回收器。如果未被回收的对象将较
  大的空闲内存块分割成许多较小的内存块，则空闲内存将会呈现出碎片化趋势，即可
  用空间散布在众多可以用于顺序分配的小内存块中，而不是少数几个大内存块里。

> 图 7.1

![chapter-07-1.drawio.svg](./images/chapter-07-1.drawio.svg)

```c
sequentialAllocate(n):
    result <- free
    newFree <- result+ n
    if newFree> l imit
        return null /*内存耗尽*/
    free <- newFree
    return result
```

## 空闲链表分配
