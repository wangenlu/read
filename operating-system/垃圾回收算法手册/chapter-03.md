# 第三章 标记-整理回收

关键字：

- 外部碎片 external fragmentation
- 双指针回收算法 tow finger
- 滑动回收算法 Lisp 2 算法
- forwarding address
- 引线整理算法 threaded compaction
- 单次遍历算法(one-pass algorithm )

内存碎片化是非移动式回收器无法解决的问题之一，即:
尽管堆中仍有可用空间，但是内存管理器却无法找到-块连续内存块来满足较大对象的分配需求，或者需要花费较长时间才能找到合适的空闲内存。

标记-整理算法的执行需要经过数个阶段:首先是标记阶段，其相关内容我们在上一章已经讨论过;然后是整理阶段，即移动存活对象，
同时更新存活对象中所有指向被移动对象的指针。在不同算法中，堆的遍历次数、整理过程所遵循的顺序、对象的迁移方式都有所不同。
整理顺序(compactionorder)会影响到程序的局部性。移动式回收器重排堆中对象时所遵循的顺序包括以下3种:

- 任意顺序:对象的移动方式与它们的原始排列顺序和引用关系无关。
- 线性顺序:将具有关联关系的对象排列在一起，如具有引用关系的对象，或者同一数据结构中的相邻对象。
- 滑动顺序:将对象滑动到堆的一端，“挤出”垃圾，从而保持对象在堆中原有的分配顺序。

## 双指针回收算法

- 简单
- 两次遍历
- 最佳适用场景为只包含固定大小对象的区域
- 双指针算法重排列堆中对象的顺序是任意式的，因此会破坏赋值器的局部性

## Lisp 2 算法

- 需要三次遍历
- Lisp2 算法的主要缺陷在于，它需要在每个对象头部额外增加一个完整的头域来记录转发地址(标记位也可以复用该域)

在标记阶段结束之后的第一次堆遍历过程中，回收器将会计算出每个存活对象的最终地址(即转发地址)，并且将其保存在对象的 forwardingAddress 域中(见算法3.2 )。
computeLocations 方法需要3个参数:堆中待整理区域的起始地址、结束地址、整理目标区域起始地址。目标区域通常与待整理区域相同，但并行回收器可能会为每个线程设定不同的来源和目标区域。
用 computeLocations 方法在堆中移动两个指针:指针 scan 对来源区域中的所有(存活的或死亡的)对象进行迭代，指针 free 指向目标区域中的下一个空闲位置。如果指针scan遍历到的对象是存活的，
意味着该对象(最终)会被移动到指针 free 所指向的位置。此时回收器将指针 free 写入对象的 forwardingAddress 域，然后根据对象的大小向前移动指针free ( 需要考虑对齐填充)。
如果遍历到死亡对象，则将其忽略。

在第二次堆遍历过程(算法3.2中的 updateReferences 方法)中，回收器将使用对象头
域中记录的转发地址来更新赋值器线程根以及被标记对象中的引用，该操作将确保它们指向
对象的新位置。在第三次遍历过程中，relocate 最终将每个存活对象移动到其新的目标位置。

## 引线整理算法

## 单次遍历算法