# 第三章 标记-整理回收

关键字：

- 外部碎片 external fragmentation
- 双指针回收算法 tow finger
- 滑动回收算法 Lisp 2 算法
- forwarding address
- 引线整理算法 threaded compaction
- 单次遍历算法(one-pass algorithm )

内存碎片化是非移动式回收器无法解决的问题之一，即:
尽管堆中仍有可用空间，但是内存管理器却无法找到-块连续内存块来满足较大对象的分配需求，或者需要花费较长时间才能找到合适的空闲内存。

标记-整理算法的执行需要经过数个阶段:首先是标记阶段，其相关内容我们在上一章已经讨论过;然后是整理阶段，即移动存活对象，
同时更新存活对象中所有指向被移动对象的指针。在不同算法中，堆的遍历次数、整理过程所遵循的顺序、对象的迁移方式都有所不同。
整理顺序(compactionorder)会影响到程序的局部性。移动式回收器重排堆中对象时所遵循的顺序包括以下3种:

- 任意顺序:对象的移动方式与它们的原始排列顺序和引用关系无关。
- 线性顺序:将具有关联关系的对象排列在一起，如具有引用关系的对象，或者同一数据结构中的相邻对象。
- 滑动顺序:将对象滑动到堆的一端，“挤出”垃圾，从而保持对象在堆中原有的分配顺序。

## 双指针回收算法

- 简单
- 两次遍历
- 最佳适用场景为只包含固定大小对象的区域
- 双指针算法重排列堆中对象的顺序是任意式的，因此会破坏赋值器的局部性

## Lisp 2 算法

- 需要三次遍历
- Lisp2算法的主要缺陷在于，它需要在每个对象头部额外增加一个完整的头域来记录转发地址(标记位也可以复用该域)