# ZGC

- 无暂停 GC 与 CMS、Scanvenge 等传统算法不同，它的停顿时间不会随着堆大小的增加而线性增加
- ZGC 与 G1 的区别在于：它可以做到并发转移（拷贝）对象。
- 并发转移关键技术
- 活跃对象不被漏标，三色标记算法
- read barrier
- 染色指针（colored pointer）
- Marked0
- Marked1
- Remapped
- Finalizable
- 地址视图
- 地址视图的巧妙之处就在于，一个在物理内存上存放的对象，被映射在了三个虚拟地址上。
- Relocate 阶段
- Remap 阶段
- Mark 阶段负责标记活跃对象
- Relocate 阶段负责活跃对象转移
- ReMap 阶段负责地址视图统一

从功能原理上看，无暂停 GC 与 CMS、Scanvenge 等传统算法不同，它的停顿时间不会随着堆大小的增加而线性增加。以 ZGC 为例，它的最大停顿时间不超过 10ms ，注意不是平均，也不是随机，而是最大不超过 10ms

很多垃圾回收算法中，在进行对象转移时都是需要 “世界停止”（Stop The World，STW）的，而对象转移往往是垃圾回收过程最耗时的一个环节，并且随着堆的增大，这个时间也会跟着增加。ZGC 则不同，在应用线程运行的同时，GC 线程也可以进行对象转移，这样就相当于把整个 GC 最耗时的环节放在应用线程后台默默执行，不需要一个长时间的 STW 来等待。这也正是 ZGC 停顿时间很小的主要原因。

## 并发转移关键技术 read barrier

请你试想一下，当应用线程去读一个对象时，GC 线程刚好正在搬移这个对象。如果 GC 线程没有搬移完成，那么应用线程可以去读这个对象的旧地址；如果这个对象已经搬移完成，那么可以去读这个对象的新地址。那么判断这个对象是否搬移完成的动作就可以由 read barrier 来完成。