# 02 Java 并发机制的底层实现原理

- volatile 定义与原理
- volatile 可见性
- volatile 禁止指令重排序
- volatile 通过内存屏障，可以让处理器的缓存写会到主内存。一个处理器的缓存回写到内存会导致其他处理器的缓存无效
- volatile 的字段写入的伪共享问题（可以通过字节填充解决）
- synchronized 与JAVA 对象头
- 偏向锁，锁获取与锁取消
- 轻量级锁，加锁与解锁
- 重量级锁
- CAS ABA 问题
- CAS 循环时间长的开销大
- CAS 只能保证一个共享变量的原子操作


## 锁的对比

锁|优点|缺点|适用场景
---|---|--|------|
偏向锁  | 加锁和解锁不需要额外的消耗，和执行非同步方法相比仅存在纳秒级的差距 | 如果线程间存在锁竞争，会带来额外的锁撤销的消耗 | 适用于只有一个线程访问同步块场景
轻量级锁 | 竞争的线程不会阻塞，提高了程序的响应速度 | 如果始终得不到锁竞年的线程，使用自旋会消耗 CPU | 追求响应时间 同步块执行速度非常快
重量级锁 | 线程竞争不使用自旋，不会消耗CPU | 线程阻塞，响应时间缓慢 | 追求吞吐量 同步块执行速度较长

## 原子操作

- 第一个机制通过总线锁保证原子性
- 第二个机制是通过缓存锁定保证原子性

## 伪共享

伪共享（false-sharing）的意思是说，当两个线程同时各自修改两个相邻的变量，由于缓存是按缓存块来组织的，当一个线程对一个缓存块执行写操作时，必须使其他线程含有对应数据的缓存块无效。这样两个线程都会同时使对方的缓存块无效，导致性能下降。
