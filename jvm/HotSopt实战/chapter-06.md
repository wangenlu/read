# 第六章 栈

> 概要

- 真实机器:程序是如何执行的、x86指令集与寄存器和栈的关系
- 扩展知识:ARM让Java 硬件级加速成为可能
- Java栈
- 栈帧、局部变量、操作数栈
- HotSpot对硬件寄存器资源的利用
- 栈顶缓存技术
- VM中如何实现调用Java方法


> 关键字

- x86 8个32位通用寄存器
- 栈帧 stack frame
- 活动记录
- call 指令
- ret 指令
- java 栈
- 寄存器式指令集
- 栈式指令集
- 基于栈的执行引擎
- 栈帧
- 局部变量表
- bytecodeinterpreter_x86.hpp
- 操作数栈
- JavaCalls
- javaCalls.cpp
- StubRoutines::call_stub
- stubRoutines.cpp
- J:Java帧(编译)。 P214
- j:Java帧(解释)。
- V: VM帧(C/C++).
- C: C/C++帧 。
- v:其他帧，JVM内部生成的机器代码片段(如stub等)
- 解释器
- 编译器
- Routine
- templateTable_x86.cpp

## 寄存器

- %eax. %ecx. %edx;
- %ebx. %edi. %eci;
- %ebp. %esp.

这8个寄存器按照惯例，被分为三组。其中，最后两个%ebp、%esp 具有特殊用途，用来保存指向程序栈中特定位置的指针。
多数指令具有一个或多个操作数(operand)，操作数表示执行该指令操作中要引用的源数据值，以及放置指令执行结果的目标数据。x86支持3种操作数格式:

- 立即数(immediate)，即常量;
- 寄存器(register)， 表示寄存器中存的值;
- 存储器引用，根据某个有效地址访问某个存储器。


根据惯例，寄存器%eax、%edx、%ecx被划分为调用者保存(caller-saved) 寄存器，当过程A调用B时，B可以覆盖这些寄存器，而不会破坏任何A所需要的数据。另外，寄存器%ebx、%esi、%edi 被划分为被调用者保存(callee-saved) 寄存器，这就是说，B必须在覆盖它们之前，将这些寄存器的值保存到栈中。

## x86栈

由于x86栈是向内增长的，也就是说栈在增长时，地址却是减少的;栈在收缩时，地址是增加的。栈指针%esp保存着栈顶元素的地址，且栈项元素的地址是所有栈中元素中最低的，随着push和pop指令的不断执行，栈指针执行的地址也是不断变化的。帧指针%ebp保存的是栈帧的帧底地址，在一个栈帧运动的过程中，栈底指针是固定的。

> 可以这样理解，入栈(push)操作可以当做是向一个盒子里面放书，书的高度是在增加的，而x86的栈是和直觉不太一样，栈的地址%esp得值是减少的。

## 函数调用

一个函数调用包括将数据(以函数参数和返回值的形式)和控制从代码的一部分传递到 另一部分。数据传递、局部变量的分配和释放是通过操纵程序栈来实现的。
在编译理论中，用一个术语用来表示这种控制转移，称为活动记录(activation record)。一般来说，一个活动记录由3部分组成:被调用者的局部变量、返回调用者的地址和传入的参数。活动记录的结构，是由具体的平台定义和实现的。

## Java 栈


## HotSpot 中的栈

与C/C++栈不同，Java 栈是由虚拟机自动管理的，对程序员不可见，即程序员不能直接操纵栈。Java开发中，每当我们在程序中使用new生成一个对象，对象的引用存放在栈里，而对象是存放在堆里的。可以看出栈在Java核心的重要位置。
每当启用一个线程时，JVM就为线程分配一个Java栈，栈是以帧为单位保存当前线程的运行状态。某个线程正在执行的方法称为当前方法，当前方法使用的栈帧称为当前帧，当前方法所属的类称为当前类，当前类的常量池称为当前常量池。当线程执行一个方法时，它会跟踪当前常量池。

每当线程调用一个Java方法时，JVM就会在该线程对应的栈中压入一个帧，这个帧自然就成了当前帧。当执行这个方法时，它使用这个帧来存储参数、局部变量和中间运算结果。

Java栈上的所有数据都是私有的。任何线程都不能访问另一个线程的栈数据。所以我们不用考虑多线程情况下栈数据访问同步的情况。
像方法区和堆一样， Java 栈和帧在内存中也不必是连续的，帧可以分布在连续的栈里，也可以分布在堆里。


## 操作数栈


Java虚拟机的解释执行引擎被称为基于栈的执行引擎，其中所指的栈就是指操作数栈。操作数栈也常被称为操作栈，或表达式栈(expression stack)。 操作数栈的深度由Code属性`max_stacks`在编译期便可确定。Class 文件中，类似stack=3这样的参数，其数值则表示在该方法的执行过程中，操作数栈大小始终不过超过这个数值。

操作数栈和局部变量区一样，`操作数栈`也被组织成一个以字长为单位的数组。但和前者不同的是，它不是`通过索引`来访问的，而是通过入栈和出栈来访问的。可把操作数栈理解为存储计算时临时数据的存储区域。

虚拟机在操作数栈中存储数据的方式与在局部变量区中是一样的，如int、long、float、double、reference 和returnType的存储。对于byte、short以及char类型的值在压入到操作数栈之前，`也会被转换为int`。除了PC寄存器之外，JVM并没有实现任何寄存器。

JVM指令是从操作数栈中而不是从寄存器中取得操作数的，因此它的运作方式是基于栈的，而不是基于寄存器的。操作数栈其实就是一个临时数据存储区域，它是通过入栈和出栈来进行操作的。虚拟机把操作数栈作为它的工作区。帧数据区除了`局部变量区`和`操作数栈`外，Java栈帧还需要一些数据来支持常量池解析、正常方法返回以及异常分发机制。
这些数据都保存在Java栈帧的帧数据区中。当JVM执行到需要常量池数据的指令时，它都会通过帧数据区中指向常量池的指针来访问它。

除了处理常量池解析外,帧里的数据还要处理Java方法的正常结束和异常终止。如果是通过return正常结束，则当前栈帧从Java栈中弹出，恢复发起调用的方法的栈。如果方法有返回值，JVM会把返回值压入到发起调用方法的操作数栈。

为了处理Java方法中的异常情况，帧数据区还必须保存一个对此方法`异常表的引用`。当异常抛出时，JVM给catch块中的代码。如果没发现，方法立即终止，然后JVM用帧区数据的信息恢复发起调用的方法的帧。然后再发起调用方法的上下文重新抛出同样的异常。

