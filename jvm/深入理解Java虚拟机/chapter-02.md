# 第 2 章　 Java 内存区域与内存溢出异常

- 堆
- 程序计数器
- 方法区
- 本地方法区
- 虚拟机栈
- 本地方法栈
- 运行时常量池
- 最大栈深度
- StackOverflowError
- OutOfMemoryError 异常
- 元空间（Metaspace）来代替
- 本地内存（直接内存）
- -Xmx -Xms
- -XX：MaxPermSize
- 内存分配 “指针碰撞”（BumpThePointer）
- 内存分配 “空闲列表”（FreeList）
- 本地线程分配缓冲（ThreadLocalAllocationBuffer，TLAB）
- 对象的内存布局
- PermGenspace 永久代（新版本 jdk 已经废弃）
- -XX：MaxDirectMemorySize
- -XX：MaxMetaspaceSize
- -XX：MetaspaceSize
- -XX：MinMetaspaceFreeRatio

## 方法区

方法区（MethodArea）与 Java 堆一样，是各个线程共享的内存区域，它用于存储已被虚拟机加载的类型信息、常量、静态变量、即时编译器编译后的代码缓存等数据。
虽然《Java 虚拟机规范》中把方法区描述为堆的一个逻辑部分，但是它却有一个别名叫作“非堆”（NonHeap），目的是与 Java 堆区分开来。

## 运行时常量池

运行时常量池（RuntimeConstantPool）是方法区的一部分。Class 文件中除了有类的版本、字段、方法、接口等描述信息外，
还有一项信息是常量池表（ConstantPoolTable），用于存放编译期生成的各种字面量与符号引用，这部分内容将在类加载后存放到方法区的运行时常量池中。

运行时常量池相对于 Class 文件常量池的另外一个重要特征是具备动态性，Java 语言并不要求常量一定只有编译期才能产生，也就是说，
并非预置入 Class 文件中常量池的内容才能进入方法区运行时常量池，运行期间也可以将新的常量放入池中，这种特性被开发人员利用得比较多的便是 String 类的 intern()方法。

## 对象的内存布局

在 HotSpot 虚拟机里，对象在堆内存中的存储布局可以划分为三个部分：对象头（Header）、实例数据（InstanceData）和对齐填充（Padding）。

HotSpot 虚拟机对象的对象头部分包括两类信息。第一类是用于存储对象自身的运行时数据，如哈希码（HashCode）、GC 分代年龄、锁状态标志、线程持有的锁、偏向线程 ID、偏向时间戳等，这部分数据的长度在 32 位和 64 位的虚拟机（未开启压缩指针）中分别为 32 个比特和 64 个比特，官方称它为“MarkWord”。对象需要存储的运行时数据很多，其实已经超出了 32、64 位 Bitmap 结构所能记录的最大限度，但对象头里的信息是与对象自身定义的数据无关的额外存储成本，考虑到虚拟机的空间效率，MarkWord 被设计成一个有着动态定义的数据结构，以便在极小的空间内存储尽量多的数据，根据对象的状态复用自己的存储空间。例如在 32 位的 HotSpot 虚拟机中，如对象未被同步锁锁定的状态下，MarkWord 的 32 个比特存储空间中的 25 个比特用于存储对象哈希码，4 个比特用于存储对象分代年龄，2 个比特用于存储锁标志位，1 个比特固定为 0，在其他状态（轻量级锁定、重量级锁定、GC 标记、可偏向）。

> 表 21 　 HotSpot 虚拟机对象头 MarkWord

| 存储内容                              | 标志位 | 状态             |
| ------------------------------------- | ------ | ---------------- |
| 对象哈希码、对象分代年龄              | 01     | 未锁定           |
| 指向锁记录的指针                      | 00     | 轻量级锁定       |
| 指向重量级锁的指针                    | 10     | 膨胀(重量级锁定) |
| 空,不需要记录信息                     | 11     | GC 标记          |
| 偏向线程 ID、偏向时间戳、对象分代年龄 | 01     | 可偏向           |

## 对象的访问定位

创建对象自然是为了后续使用该对象，我们的 Java 程序会通过栈上的 reference 数据来操作堆上的具体对象。
由于 reference 类型在《Java 虚拟机规范》里面只规定了它是一个指向对象的引用，并没有定义这个引用应该通过什么方式去定位、访问到堆中对象的具体位置，
所以对象访问方式也是由虚拟机实现而定的，主流的访问方式主要有使用句柄和直接指针两种：

·如果使用句柄访问的话，Java 堆中将可能会划分出一块内存来作为句柄池，reference 中存储的就是对象的句柄地址，而句柄中包含了对象实例数据与类型数据各自具体的地址信息，其结构如图 22 所示。

·如果使用直接指针访问的话，Java 堆中对象的内存布局就必须考虑如何放置访问类型数据的相关信息，reference 中存储的直接就是对象地址，如果只是访问对象本身的话，就不需要多一次间接访问的开销，
这两种对象访问方式各有优势，使用句柄来访问的最大好处就是 reference 中存储的是稳定句柄地址，在对象被移动（垃圾收集时移动对象是非常普遍的行为）时只会改变句柄中的实例数据指针，而 reference 本身不需要被修改。

## String::intern

String::intern()是一个本地方法，它的作用是如果字符串常量池中已经包含一个等于此 String 对象的字符串，则返回代表池中这个字符串的 String 对象的引用；
否则，会将此 String 对象包含的字符串添加到常量池中，并且返回此 String 对象的引用。
